# Java内存模型

## 处理器，高速缓存，主内存的交互关系

![hardware_cache.png](hardware_cache.png)

## 主内存与工作内存

Java内存模型规定了所有的变量都存储在主内存中，每条线程有自己的工作内存。线程的工作内存保存了被改线程使用的变量的主内存副本，线程对变量的读取，赋值都必须在工作内存中进行，而
不能直接读取写入主内存中的数据。不同的线程之间也无法直接访问对方工作内存的变量。

## 内存间相互操作

lock: 作用于主内存，把变量标识为线程独占   
unlock： 作用于主内存，释放锁定的变量   
read：作用于主内存   
load：作用于工作内存   
use：作用于工作内存   
assign： 作用于工作内存   
store：作用于工作内存   
write: 作用于主内存   

不允许read和load，store和write操作之一单独出现
一个变量在同一时刻只能一条线程进行lock
在执行unlock操作之前，必须把变量同步到主内存当中

## volatile型变量的特俗规则 

### 保证变量的可见性

在使用之前会刷新取到最新值

### 禁止指令重排序

lock操作实现了内存屏障，不能把后面的指令重排序到内存屏障之前的位置

### 先行发生原则
#### 在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作
#### 一个unlock先行发生于后面对同一个锁的lock操作
#### volatile变量的写操作先发生与后面对这个变量的读操作 {id="volatile_desc"}
#### Thread对象的start方法先行发生于此线程的每一个动作
#### 线程中的所有操作先行发生于对此线程的终止检测，用Thread::join方法是否结束，通过Thread::isAlive()的返回值检测
#### 线程interupt方法的调用先生发生于被中断线程的代码检测到中断事件的发生，通过Thread::interrupted()方法检测到是否有中断发生


